---
title: Dragon Ball
category: Suuuuuprrrrrr
description: Four-star dragon ball with layered fills and a specular highlight.
---

import ExampleTabs from "@examples/components/ExampleTabs.svelte";
import DragonBall from "./DragonBall.svelte";

<ExampleTabs>
  <DragonBall client:visible slot="scene" />
  <Fragment slot="code">
```typescript
import { Pluton2D } from "pluton-2d";

type SceneParams = { radius: number; starSize: number; specular: number };

const svgElement = document.querySelector("svg#dragon-ball") as SVGSVGElement;
const scene = new Pluton2D<SceneParams>(svgElement, {
  radius: 120,
  starSize: 16,
  specular: 0.8,
});

const geometry = scene.geometry.group();
const dimensions = scene.dimensions.group();

const sphereFillId = scene.addHatchFill("#fb923c", 0.3);
const starFillId = scene.addHatchFill("#b91c1c", 0.5);
const CIRCLE_HANDLE_FACTOR = 0.5522847498;

const appendCircle = (path: any, centerX: number, centerY: number, radiusValue: number) => {
  const handleOffset = radiusValue * CIRCLE_HANDLE_FACTOR;
  path
    .moveToAbs(centerX - radiusValue, centerY)
    .cubicToAbs(
      centerX - radiusValue,
      centerY + handleOffset,
      centerX - handleOffset,
      centerY + radiusValue,
      centerX,
      centerY + radiusValue,
    )
    .smoothCubicToAbs(centerX + radiusValue, centerY + handleOffset, centerX + radiusValue, centerY)
    .smoothCubicToAbs(centerX + handleOffset, centerY - radiusValue, centerX, centerY - radiusValue)
    .smoothCubicToAbs(centerX - radiusValue, centerY - handleOffset, centerX - radiusValue, centerY)
    .close();
};

scene.draw((params) => {
  const sphereRadius = params.radius;
  const starOuterRadius = params.starSize;
  const starInnerRadius = starOuterRadius * 0.44;
  const starCenterOffset = sphereRadius * 0.42;

  const spherePath = geometry.path({ className: "demo-dragon-sphere", fill: sphereFillId });
  appendCircle(spherePath, 0, 0, sphereRadius);

  const starPath = geometry.path({ className: "demo-dragon-stars", fill: starFillId });
  const starCenters = [
    { x: 0, y: -starCenterOffset },
    { x: starCenterOffset, y: 0 },
    { x: 0, y: starCenterOffset },
    { x: -starCenterOffset, y: 0 },
  ];

  for (const starCenter of starCenters) {
    for (let pointIndex = 0; pointIndex < 10; pointIndex++) {
      const pointAngle = -Math.PI / 2 + (pointIndex * Math.PI) / 5;
      const pointRadius = pointIndex % 2 === 0 ? starOuterRadius : starInnerRadius;
      const pointX = starCenter.x + Math.cos(pointAngle) * pointRadius;
      const pointY = starCenter.y + Math.sin(pointAngle) * pointRadius;
      if (pointIndex === 0) starPath.moveToAbs(pointX, pointY);
      else starPath.lineToAbs(pointX, pointY);
    }
    starPath.close();
  }

  const dimensionPath = dimensions.dimension({ className: "dragon-dim" });
  dimensionPath.moveToAbs(-sphereRadius, sphereRadius + 24).lineTo(2 * sphereRadius, 0);

  if (params.specular > 0) {
    const specularPath = geometry.path({ className: "demo-dragon-specular" });
    appendCircle(specularPath, -sphereRadius * 0.34, -sphereRadius * 0.34, sphereRadius * 0.36 * params.specular);
  }
});
```
  </Fragment>
</ExampleTabs>
