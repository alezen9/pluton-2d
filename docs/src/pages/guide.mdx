---
layout: ../layouts/MarkdownLayout.astro
title: Guide
currentPage: /guide
description: Get started with Pluton 2D, setup, coordinate system, geometry primitives, dimensions, and rendering.
---

# Guide

Pluton 2D is a small library I built for technical drawing in SVG. It handles coordinate transforms, geometry builders, hatching, dimensions, and a render loop that only writes to the DOM when something changed. I'm sharing it in case you need something similar.

This guide walks through concepts, patterns, and the reasoning behind them. If you're looking for method signatures and parameter tables, check the [API reference](/api).

## Install and setup

```bash
npm install pluton-2d
```

Import the stylesheet first. It provides defaults for the grid, axes, and dimensions. Then create a scene by passing an SVG element and your parameters. The SVG needs CSS width/height or a `viewBox` so Pluton knows the canvas size:

```typescript
import "pluton-2d/style.css";
import { Pluton2D } from "pluton-2d";

const svg = document.querySelector("svg")!;
const scene = new Pluton2D(svg, {
  params: { width: 200, height: 100 },
});

scene.enablePan(true);
scene.enableZoom(true);

const geom = scene.geometry.group();

scene.draw((p) => {
  const path = geom.path();
  path
    .moveToAbs(-p.width / 2, -p.height / 2)
    .lineTo(p.width, 0)
    .lineTo(0, p.height)
    .lineTo(-p.width, 0)
    .close();
});
```

Notice that `geom` is created _outside_ the draw callback. This matters. Groups persist across frames and own the actual SVG elements. Builders (what you get from `geom.path()`) are temporary handles you grab each frame to describe what to draw. If you created the group inside `draw`, you'd get a new SVG group every frame and leak DOM nodes.

The engine diffs attributes. If your draw callback produces the same output as last frame, nothing gets written to the DOM.

### Reactive params

The `params` object is wrapped in a Proxy. Mutate a property, the scene redraws. Redraws are capped at 60 FPS:

```typescript
scene.params.width = 300; // triggers redraw

Object.assign(scene.params, { width: 250, height: 150 }); // also works

// Don't reassign the whole object. The Proxy is on the original
// scene.params = { ... };  ← won't trigger redraws
```

Parameters must be a flat object. Nested objects throw at construction time. I went with a flat Proxy because deep reactivity adds complexity for little gain here. You're feeding numbers into a draw loop, not managing app state. If you need complex state, keep it outside `scene.params` and sync the flat values in your draw callback.

When you're done, call `scene.dispose()` to clean up listeners and DOM.

## Coordinate system

Pluton uses a center-origin, Y-up coordinate system. Same convention as math or engineering drawings, not screen coordinates where Y goes down.

- Origin: center of viewport
- Positive X → right
- Positive Y → **up**
- `lineTo(10, 20)` moves right 10, up 20

Why Y-up? I kept getting signs wrong with Y-down, arcs curving the wrong way, dimension text upside down. The rendering layer flips Y-coordinates so your math maps correctly to SVG. Arc directions are adjusted too, so `clockwise = true` actually looks clockwise on screen.

## Static vs dynamic

If you have geometry that doesn't change (background grids, reference shapes, fixed annotations), you can mark the group as static:

```typescript
const bg = scene.geometry.group();
bg.setDrawUsage("static"); // commits once

const fg = scene.geometry.group(); // dynamic by default

scene.draw((p) => {
  // Static. Still call path() every frame, engine skips DOM write
  const bgPath = bg.path();
  bgPath.moveToAbs(-100, -100).lineTo(200, 0).lineTo(0, 200).close();

  // Dynamic. DOM updates every frame
  const fgPath = fg.path();
  fgPath.moveToAbs(0, 0).lineTo(p.width, 0).lineTo(0, p.height).close();
});
```

After the first render, the engine skips all DOM writes for static groups. You still call `path()` each frame (the engine expects the same structure), but it short-circuits before touching the DOM. Helps when you have a complex background behind a few moving parts.

Call `clear()` or `setDrawUsage("dynamic")` to reset the flag if you need to update static geometry later.

## Styling

All styling uses CSS custom properties on `.pluton-root`. You can override defaults per-instance without touching JavaScript:

```css
.pluton-root {
  --pluton-grid-minor-stroke: rgba(0, 0, 0, 0.025);
  --pluton-grid-major-stroke: rgba(0, 0, 0, 0.12);
  --pluton-grid-stroke-width: 0.5;

  --pluton-axis-color: rgba(0, 0, 0, 0.2);
  --pluton-axis-stroke-width: 1;
  --pluton-axis-dash: 5 5;

  --pluton-geometry-stroke: rgba(0, 0, 0, 0.7);
  --pluton-geometry-stroke-width: 1;

  --pluton-hatch-color: rgba(0, 39, 50, 0.14);

  --pluton-dim-color: black;
  --pluton-dim-stroke-width: 1;
  --pluton-dim-text-color: rgba(0, 0, 0, 0.6);
  --pluton-dim-font-size: 12px;
  --pluton-dim-font-family: system-ui, sans-serif;
}
```

### Custom classes

When CSS variables aren't enough, pass `className` to `path()` or `dimension()`:

```typescript
const path = geom.path({ className: "my-path" });

// In CSS:
// .pluton-root .pluton-geometry path.my-path { stroke: #e11d48; }
```

`path()` also accepts `fill`, `stroke`, and `fillRule` for hatch fills, custom colors, or cutouts. Geometry groups support `scale(x, y)` and `translate(x, y)` for positioning.

### Hatch fill

`addHatchFill(color, opacity?)` returns a fill ID you pass to `path({ fill })`:

```typescript
const blueFill = scene.addHatchFill("#2563eb");
const orangeFill = scene.addHatchFill("#ea580c", 0.45);

geom.path({ fill: blueFill }).moveToAbs(...).lineTo(...).close();
geom.path({ fill: orangeFill, fillRule: "evenodd" }).moveToAbs(...).close();
```

Each path uses whatever fill you specify, or falls back to the built-in default hatch. Toggle all fills with `scene.enableFill(false)` to hide them, `scene.enableFill(true)` to show them. For stroke-only geometry, set `fill: "none"` on the path or in CSS.

### Pencil filter

Gives geometry a hand-drawn look. You can adjust intensity at runtime:

```typescript
scene.enableFilter(true);
scene.setFilterIntensity(1.25); // default

// Can also call inside draw callbacks
scene.draw(() => {
  scene.setFilterIntensity(1.25);
});
```

Heads up: Safari has trouble with this filter during zoom, especially with many paths. If you see weird artifacts on WebKit, try lowering the intensity or disabling the filter while zooming.

## Camera controls

Pan and zoom are opt-in:

```typescript
scene.enablePan(true); // middle-mouse drag, or shift + left-click
scene.enableZoom(true); // mouse wheel, 1×-20× range

scene.resetCamera(); // smooth animation back to origin
```

Camera movement uses exponential easing so it doesn't overshoot. `resetCamera()` animates back to origin instead of jumping.

### Responsive scaling

On mobile and tablet, you can scale the entire view down to give geometry more room. This is different from camera zoom. It scales the output without changing your coordinate system or pan/zoom behavior:

```typescript
// Using matchMedia for clean breakpoint handling
const mobileQuery = window.matchMedia("(max-width: 640px)");
const tabletQuery = window.matchMedia(
  "(min-width: 641px) and (max-width: 1024px)",
);

const updateScale = () => {
  if (mobileQuery.matches) {
    scene.setViewScale(0.7); // mobile: 70% scale
  } else if (tabletQuery.matches) {
    scene.setViewScale(0.85); // tablet: 85% scale
  } else {
    scene.setViewScale(1.0); // desktop: full scale
  }
};

updateScale();
mobileQuery.addEventListener("change", updateScale);
tabletQuery.addEventListener("change", updateScale);
```

The scale interpolates smoothly like pan and zoom. Camera state is preserved. If the user zoomed in 3×, they stay at 3× after the view scale changes. `moveTo(100, 100)` still means the same world position no matter what scale you set.

## When to use Pluton 2D

I built Pluton for technical drawing. It does SVG, hatching, dimensions, and tries to keep DOM churn low. It's not trying to replace everything. Here's roughly where it fits.

### Good fit

- Technical drawings, blueprints, engineering diagrams
- Annotation-heavy scenes (dimensions, ticks, callouts)
- Inspectable or exportable SVG workflows
- Interactive scenes with moderate redraw frequency

### Charting libraries might be a better fit when

- Your goal is data visualization with standard chart types
- You need chart primitives out of the box (scales, legends, tooltips)
- You're working with time-series data, bar charts, or scatter plots

### Canvas might be a better fit when

- You're doing high-frequency animation (60+ shapes moving per frame)
- You have lots of moving primitives and hit SVG/DOM limits
- You don't need inspectable, exportable SVG

### WebGL/WebGPU might be a better fit when

- You need GPU-driven rendering or advanced visual effects
- You're building shader-driven pipelines or post-processing chains
- You're working with 3D or large-scale real-time rendering
