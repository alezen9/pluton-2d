---
import Layout from "../layouts/Layout.astro";
import CodeBlock from "../components/CodeBlock.astro";

const installCode = `npm install pluton-2d`;

const setupCode = `import "pluton-2d/style.css";
import { Pluton2D } from "pluton-2d";

const svg = document.querySelector("svg")!;
const scene = new Pluton2D(svg, { width: 200, height: 100 });

scene.enablePan(true);
scene.enableZoom(true);

const geom = scene.geometry.group();

scene.draw((p) => {
  const path = geom.path();
  path
    .moveToAbs(-p.width / 2, -p.height / 2)
    .lineTo(p.width, 0)
    .lineTo(0, p.height)
    .lineTo(-p.width, 0)
    .close();
});`;

const reactiveCode = `// Mutate a single param — triggers redraw
scene.params.width = 300;

// Mutate several at once
Object.assign(scene.params, { width: 250, height: 150 });

// Don't reassign the whole object — the Proxy is on the original
// scene.params = { ... };  ← won't trigger redraws`;

const staticCode = `const bg = scene.geometry.group();
bg.setDrawUsage("static"); // commit runs once, then stops

const fg = scene.geometry.group(); // dynamic by default

scene.draw((p) => {
  // Static — still call path() every frame, engine skips the DOM write
  const bgPath = bg.path();
  bgPath.moveToAbs(-100, -100).lineTo(200, 0).lineTo(0, 200).close();

  // Dynamic — DOM updates every frame
  const fgPath = fg.path();
  fgPath.moveToAbs(0, 0).lineTo(p.width, 0).lineTo(0, p.height).close();
});`;

const cssVarsCode = `.pluton-root {
  --pluton-grid-minor-stroke: rgba(0, 0, 0, 0.025);
  --pluton-grid-major-stroke: rgba(0, 0, 0, 0.12);
  --pluton-grid-stroke-width: 0.5;

  --pluton-axis-color: rgba(0, 0, 0, 0.2);
  --pluton-axis-stroke-width: 1;
  --pluton-axis-dash: 5 5;

  --pluton-geometry-stroke: rgba(0, 0, 0, 0.7);
  --pluton-geometry-stroke-width: 1;

  --pluton-hatch-color: rgba(0, 39, 50, 0.14);

  --pluton-dim-color: black;
  --pluton-dim-stroke-width: 1;
  --pluton-dim-text-color: rgba(0, 0, 0, 0.6);
  --pluton-dim-font-size: 12px;
  --pluton-dim-font-family: system-ui, sans-serif;
}`;

const customClassCode = `// Pass a class name when requesting a builder
const path = geom.path({ className: "my-path" });

// Style it in CSS
// .pluton-root .pluton-geometry path.my-path { stroke: #e11d48; }`;

const hatchCode = `// Enable hatch fill on all geometry paths
scene.enableHatchFill(true);

// Or target a single path
const path = geom.path({ className: "pluton-fill-hatch" });`;

const cameraCode = `scene.enablePan(true);   // middle-mouse drag, or shift + left-click drag
scene.enableZoom(true);  // mouse wheel — scale range 1×–20×

scene.resetCamera();     // smooth animation back to origin`;
---

<Layout title="Guide" currentPage="/guide">
  <div class="page-narrow">
    <h1>Guide</h1>

    <!-- ── Getting Started ── -->
    <h2>Getting started</h2>
    <p>Install the package:</p>
    <CodeBlock code={installCode} lang="bash" />

    <p>
      Import the stylesheet and create a scene. The SVG element needs CSS
      width/height or a viewBox to be visible:
    </p>
    <CodeBlock code={setupCode} lang="ts" />

    <p>
      Groups are created once, outside the draw callback. Builders requested
      inside are recycled — the engine only writes changed attributes.
    </p>

    <h3>Reactive params</h3>
    <p>
      Params are wrapped in a Proxy. Any mutation triggers a redraw
      automatically — redraws are capped at 60 FPS.
    </p>
    <CodeBlock code={reactiveCode} lang="ts" />

    <div class="callout">
      <p>
        <strong>Params must be flat.</strong> Nested objects will throw at
        construction time. Only top-level property mutations trigger redraws.
      </p>
    </div>

    <p>
      When you're done with a scene, call <code>scene.dispose()</code> to clean
      up event listeners and DOM elements.
    </p>

    <hr class="section-divider" />

    <!-- ── Coordinate System ── -->
    <h2>Coordinate system</h2>
    <p>
      Pluton uses <strong>center origin with Y-axis pointing up</strong> — math
      convention, not screen coordinates.
    </p>
    <ul>
      <li>Origin is at the center of the viewport</li>
      <li>Positive X → right</li>
      <li>Positive Y → <strong>up</strong></li>
      <li>
        <code>lineTo(10, 20)</code> moves right 10 units, up 20 units
      </li>
    </ul>
    <p>
      The world layer applies <code>scale(1, -1)</code> to flip Y. Arc sweep
      flags are inverted at the SVG level — pass <code>clockwise = true</code>
      and the arc renders clockwise.
    </p>

    <hr class="section-divider" />

    <!-- ── Static vs Dynamic ── -->
    <h2>Static vs dynamic groups</h2>
    <p>
      For geometry that never changes, mark the group as static. The engine
      commits it once and skips all subsequent DOM updates for that group.
    </p>
    <CodeBlock code={staticCode} lang="ts" />

    <ul>
      <li>
        <code>commit()</code> runs once, sets an internal flag
      </li>
      <li>Subsequent frames skip <code>commit()</code> for that group</li>
      <li>
        <code>clear()</code> or <code>setDrawUsage("dynamic")</code> resets it
      </li>
    </ul>
    <p>
      <strong>Static:</strong> background elements, fixed annotations, reference
      shapes.<br />
      <strong>Dynamic (default):</strong> anything that reacts to params or user
      input.
    </p>

    <hr class="section-divider" />

    <!-- ── Styling ── -->
    <h2>Styling</h2>
    <p>
      All visual styling is driven by CSS custom properties on
      <code>.pluton-root</code>. Override any of them per-instance:
    </p>
    <CodeBlock code={cssVarsCode} lang="css" />

    <h3>Custom classes</h3>
    <p>
      Pass <code>className</code> to <code>path()</code> or
      <code>dimension()</code> for fine-grained control:
    </p>
    <CodeBlock code={customClassCode} lang="ts" />

    <h3>Hatch fill</h3>
    <p>Hatch fill is opt-in. Enable globally or per-path:</p>
    <CodeBlock code={hatchCode} lang="ts" />

    <hr class="section-divider" />

    <!-- ── Camera Controls ── -->
    <h2>Camera controls</h2>
    <p>Pan and zoom are opt-in and can be reset at any time:</p>
    <CodeBlock code={cameraCode} lang="ts" />
    <p>
      Camera movement is smoothed with exponential interpolation.
      <code>resetCamera()</code> animates back to the origin rather than
      jumping.
    </p>
  </div>
</Layout>
